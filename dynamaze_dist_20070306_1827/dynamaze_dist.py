
##################################################################
#
# Do not edit this file! File generated by inc2py.py utility.
#


##################################################################
#
# Author:  Kurt W Dekker - kurtdekker at gmail dot com
# Date:    January 26, 2007
#
# Python Dynamaze game - requires Python 2.4 and Pygame 1.7
#


##################################################################
# preferences
screen_size = (640,480)

# adjust to suit how twitchy you want things to be
joystick_dead_zone = 50


##################################################################

##################################################################
# This is part of Kurt Dekker's common python library codebase.
#

##################################################################
import pygame
from pygame.constants import *

import random


##################################################################
pygame.init()
global fullscreen
fullscreen=False

scrnflags = 0
if fullscreen: scrnflags = pygame.FULLSCREEN
global screen
screen = pygame.display.set_mode(screen_size, scrnflags)

pygame.mouse.set_visible(True)
clock = pygame.time.Clock()
prevkeybits = []
keybits = []


##################################################################
cheatarray_yesno = [ "", " (by cheating)"]


##################################################################

##################################################################
#
# Author:  Kurt W Dekker
# Date:    January 20, 2007
#
# Python Playfield loader/drawer
#
# Playfields are binary files, in Motorola-endian format, consisting
# of an array of 4-byte integers.
#
# [0] - some magic - should be 0xcabeefac
# [1] - version - either 2 or 3 right now
# [2] - width (in tiles)
# [3] - height (in tiles)
# [4...x] - the tile data
#
# Each tile is a sequential lookup index into a "tilemap," basically
# an image of identical-sized tiles. NOTE! The playfield does not
# contain the dimensions of these tiles, which lets you specify them
# at runtime, giving you flexibility in changing the tilemap image
# without having to tweak the playfield.
#
# Each tile data point is essentially:
#
# 0x00000fff - index into the tilemap, upper left, across, down, etc
# 0x0ffff000 - user-defined flags (see PFE, the playfield editor)
# 0xf0000000 - user-defined animation
#
##################################################################
# This is part of Kurt Dekker's common python library codebase.
#


##################################################################
def	read_moto(f):
	a = ord( f.read(1))
	a = (a << 8) | ord( f.read(1))
	a = (a << 8) | ord( f.read(1))
	a = (a << 8) | ord( f.read(1))
	return a

##################################################################
class	playfield:
	def __init__(self,mapfile):
		f = open( datapath_art(mapfile),'rb')
		if f:
			magic = read_moto(f)
			version = read_moto(f)
			self.mapxsz = read_moto(f)
			self.mapysz = read_moto(f)
			print "size = " + `self.mapxsz` + "," + `self.mapysz`
			self.tiles = []
			for j in range(self.mapysz):
				for i in range(self.mapxsz):
					self.tiles.append( read_moto(f))
			f.close()
	def	plot( self, screenX, screenY, screenW, screenH, playfieldULX, playfieldULY, tileMap, tileXSize, tileYSize):
		# clip away portions not necessary for this view
		tileLeft   = playfieldULX / tileXSize;
		tileTop    = playfieldULY / tileYSize;
		tileRight  = tileLeft + (screenW + 2 * tileXSize - 1) / tileXSize;
		tileBottom = tileTop  + (screenH + 2 * tileYSize - 1) / tileYSize;

		if (tileLeft < 0):			   tileLeft		= 0;
		if (tileRight > self.mapxsz):  tileRight	= self.mapxsz;
		if (tileTop < 0):			   tileTop		= 0;
		if (tileBottom > self.mapysz): tileBottom	= self.mapysz;

		tileMapStride = tileMap.get_width() / tileXSize;

		for j in range( tileTop, tileBottom):
			for i in range( tileLeft, tileRight):
				screenTileX = screenX + tileXSize * i - playfieldULX
				screenTileY = screenY + tileYSize * j - playfieldULY

				c = self.tiles[ i + j * self.mapxsz]

				# <WIP> animation?

				c &= 0x00000fff
				
				# find where we're pulling from?
				sourceX = (c % tileMapStride) * tileXSize
				sourceY = (c / tileMapStride) * tileYSize

				tileRect = [sourceX, sourceY, tileXSize, tileYSize]

				# clip smoothly
				if screenTileX < screenX:
					tileRect[0] += screenX - screenTileX
					tileRect[2] -= screenX - screenTileX
					screenTileX = screenX
				if screenTileY < screenY:
					tileRect[1] += screenY - screenTileY
					tileRect[3] -= screenY - screenTileY
					screenTileY = screenY
				if screenTileX + tileXSize > screenX + screenW:
					tileRect[2] -= (screenTileX + tileXSize) - (screenX + screenW)
				if screenTileY + tileYSize > screenY + screenH:
					tileRect[3] -= (screenTileY + tileYSize) - (screenY + screenH)

				# <WIP> right and bottom clipping needed still

	
				if tileRect[2] > 0:
					if tileRect[3] > 0:
						screen.blit( tilemap, [screenTileX, screenTileY], tileRect)




##################################################################
# This is part of Kurt Dekker's common python library codebase.
#
# These are some basic data-loading functions I've found in various
# places on the net and incorporated here.

##################################################################
loaddata_data_directory = "data/"

##################################################################
def	loaddata_set_data_directory(newdir):
	global loaddata_data_directory
	loaddata_data_directory = newdir
	return

##################################################################
def	datapath_art(file):
	return loaddata_data_directory + "art/" + file
def	datapath_sound(file):
	return loaddata_data_directory + "sound/" + file


##################################################################
#taken from livewires
def load_image(file, transparent=1):
	"""
	file -- the filename of the image to load
	transparent -- whether the background of the image should be transparent.
				   Defaults to true.
				   The background colour is taken as the colour of the pixel
				   at (0,0) in the image.
	"""
	surface = pygame.image.load(datapath_art(file))
	if transparent:
		corner = surface.get_at((0, 0))
		surface.set_colorkey(corner, RLEACCEL)
	return surface		#.convert

def load_sound(file):
	"""
	Load a sound file, returning a Sound object.
	"""
	return pygame.mixer.Sound(datapath_sound(file))


##################################################################
# loads and pre-rotates an image
def	load_image_rotable( file, maxrots):
	baseimage = load_image( file)

	imagearray = []

	for i in range( maxrots):
		angle = -(i * 360) / maxrots
		rotate = pygame.transform.rotate
		imagearray.append( rotate( baseimage, angle))

	return imagearray


##################################################################
# This is part of Kurt Dekker's common python library codebase.
#
# Shapestrips are convenient ways of storing related same-sized
# small graphical pieces, such as animations.

##################################################################
class shapestrip:
	def	__init__(self,file,ysize):
		self.shape = load_image( file)
		self.xsize = self.shape.get_width()
		self.ysize = ysize
		self.numframes = self.shape.get_height() / ysize
	def	plot(self,x,y,frameno):
		dst = [x - self.xsize / 2, y - self.ysize / 2,0,0]
		src = [0, frameno * self.ysize, self.xsize, self.ysize]
		screen.blit( self.shape, dst, src)


##################################################################
# This is part of Kurt Dekker's common python library codebase.
#
# This wraps the font/printing stuff in a way that is useful to me.
#

##################################################################
JUSTIFY_LEFT   = 0x0000
JUSTIFY_CENTER = 0x0001
JUSTIFY_RIGHT  = 0x0002

class	_vgaprn:
	def	setsize(self,newsize):
		if self.currsize != newsize:
			self.currsize = newsize
		self.print_font = pygame.font.SysFont( "Times New Roman", self.currsize)
		return

	def __init__(self):
		self.currsize = 10
		self.setsize(30)
		self.color0 = (0,0,0)
		self.color1 = (255,255,255)
		self.zerowrite = 0
		self.justify = 0

	def	printf(self,x,y,str):
		if self.print_font:
			s = self.print_font.render( str,False,self.color1)
			if self.justify & JUSTIFY_CENTER:
				x -= s.get_width() / 2
			elif self.justify & JUSTIFY_RIGHT:
				x -= s.get_width()
			if self.zerowrite:
				pygame.draw.rect( screen, self.color0, (x,y,s.get_width(),s.get_height()))
			screen.blit( s, (x, y))
		return			


VGAPRN = _vgaprn()


##################################################################
joystick_initialized = 0
joystick1 = 0

jx1 = -1
jy1 = -1
jx2 = -1
jy2 = -1

prevjbuttons = 0
jbuttons = 0

##################################################################
def joystick_think():
	global joystick1, joystick_initialized

	if not joystick_initialized:
		joystick_initialized = 1
		try:
			joystick1 = pygame.joystick.Joystick(0)
		except pygame.error:
			joystick1 = 0
			return
		joystick1.init()

	if not joystick1:
		return

	global jx1, jy1, jx2, jy2
	jx1 = -1
	jy1 = -1
	jx2 = -1
	jy2 = -1

	global jbuttons, prevjbuttons
	prevjbuttons = jbuttons
	jbuttons = 0
	if joystick1.get_button(0):
		jbuttons |= 1
	if joystick1.get_button(1):
		jbuttons |= 2
	if joystick1.get_button(2):
		jbuttons |= 4
	if joystick1.get_button(3):
		jbuttons |= 8

	for i in range( joystick1.get_numaxes()):
		xxx = joystick1.get_axis(i)
		xxx = 100 + 100 * xxx
		if i == 0: jx1 = xxx
		if i == 1: jy1 = xxx
		if i == 2: jx2 = xxx
		if i == 3: jy2 = xxx
	return

def	joystick_greet_paint():
	if joystick1:
		VGAPRN.setsize(20)
		VGAPRN.justify = JUSTIFY_LEFT
		VGAPRN.printf( 4, screen.get_height() - 25, "JOY:" + `joystick1.get_numaxes()` + "AXES")
	return


##################################################################
# Individual entity objects
class	OBJ:
	def __init__(self):
		# status
		self.flag = 0
		self.dead = 0
		self.type = 0
		self.subtype = 0

		# timers, counters, etc
		self.timer = 0
		self.state = 0
		self.points = 0

		# fixed point 16.16 precision
		self.x = 0
		self.y = 0
		self.xm = 0
		self.ym = 0
		self.rot = 0
		self.rotm = 0
		self.speed = 0

		# integer (screen coords generally)
		self.ix = 0
		self.iy = 0
		self.r = pygame.Rect(0,0,0,0)

		# original locations
		self.orgx = 0
		self.orgy = 0

		# is there another entity I may be related to?
		self.cousin = -1

		# appearance
		self.frameno = 0
		self.animseq = 0

		# hitpoints
		self.hits = 0
		self.maxhits = 0	# generally, 0 will imply 1

		# miscellany
		self.gunheat = 0

		return

	# converts the fixed point down to integer, and sets up the rect
	def	calcrect(self,w,h):
		self.ix = self.x >> 16
		self.iy = self.y >> 16
		self.r.x = self.ix - w / 2
		self.r.y = self.iy - h / 2
		self.r.w = w
		self.r.h = h
		return



##################################################################
xtable8 = [ 0, 1, 1, 1, 0, -1, -1, -1]
ytable8 = [ -1, -1, 0, 1, 1, 1, 0, -1]


##################################################################
# the basic plot-a-bitmap function (blit) based on the shape center
def	plot( x, y, shape):
	r = [x - shape.get_width() / 2,y - shape.get_height() / 2,0,0]
	screen.blit( shape, r)
	return



##################################################################
# This is part of Kurt Dekker's common python library codebase.
#

##################################################################
# someday this will be rolled into a general purpose canvas manager...
CANVAS_GREET    =  1
CANVAS_INITGAME =  2
CANVAS_INITWAVE =  3
CANVAS_PLAYING  =  4
CANVAS_ENDWAVE  =  5
CANVAS_MAXIMUM  =  6




##################################################################
scrx = screen.get_width()
scry = screen.get_height()



##################################################################
def	printrect( r, title="Rect"):
	print title + " (" + `r.x` + "," + `r.y` + "," + `r.w` + "," + `r.h` + ")"


##################################################################

##################################################################
MAXROTS = 32

##################################################################
your_tank = load_image_rotable( "your_tank.png", MAXROTS)
your_tank_shadow = load_image_rotable( "your_tank_shadow.png", MAXROTS)
your_tank_turret = load_image( "your_tank_turret.png")

helicopter_body   = load_image_rotable( "helicopter_body.png",   MAXROTS)
helicopter_blades = load_image_rotable( "helicopter_blades.png", 16)
helicopter_shadow = load_image_rotable( "helicopter_shadow.png", MAXROTS)

bomb_missile = load_image_rotable( "bomb_missile.png", MAXROTS)

alien_base_center = load_image( "alien_base_center.png")
alien_gunbase1 = load_image( "alien_gunbase1.png")
alien_tank_red = load_image_rotable( "alien_tank_red.png", MAXROTS)

ss_shadows32 = shapestrip( "shadows32.png", 32)
ss_craters = shapestrip( "ss_craters.png", 40)
ss_fragments = shapestrip( "ss_fragments.png", 8)
ss_shots_and_bombs = shapestrip( "ss_shots_and_bombs.png", 16)
ss_expls_40x40_circular = shapestrip( "ss_expls_40x40_circular.png", 40)

sound_gun_firing_loop = load_sound( "gun_firing_loop1.wav")

sound_bomb_basic1 = load_sound( "bomb_basic1.wav")
sound_bomb_missile  = load_sound( "bomb_missile.wav")

sound_bonus_ship = load_sound( "bonus_ship.wav")

sounds_expls = []
sounds_expls.append( load_sound( "expl1.wav"))
sounds_expls.append( load_sound( "expl2.wav"))
sounds_expls.append( load_sound( "expl3.wav"))
sounds_expls.append( load_sound( "expl4.wav"))

##################################################################
def	silence_all():
	sound_gun_firing_loop.stop()
	return


from math import *
import math

##################################################################
# game data... I envision a STATE class instantiated here that has it all
class	gamestate:
	def	__init__(self):



##################################################################
# gamestate information common to all game

		self.score = 0
		self.highscore = 0		# read it from a file someday...
		self.ships = 0			# lives
		self.wave = 0			# steadily counts up

		# canvases loosely correspond to "views," such as the greeting screen
		# view and the playing view, etc. This will be expanded into a fully
		# flexible plug-and-play canvas system someday
		self.canvasno = 0
		self.canvastimer = 0

		self.bonus = 0			# when do you get your bonus ships?
		self.boninc = 0			# bonus ship interval

		self.worldx = 0			# control scrollview of the world
		self.worldy = 0

		self.cheating = 0

		self.grid    = []
		self.you     = OBJ()
		self.gun     = OBJ()		# just used for your gun's rotation now...
		self.shots   = []
		self.bombs   = []
		self.aliens  = []
		self.goods   = []
		self.expls   = []
		self.craters = []

		# once the alien base appears in a given wave, this becomes nonzero
		# and is added to the speed of every shot fired, and it just gets
		# nastier and nastier the longer you hang out.
		self.wave_accelerator = 0
		self.bomb_speed_bonus = 0

		# what color scheme is this level?
		self.current_colorset = 0

		# crudely this is used to determine if you're just screwing around
		# and not actively chasing and pursuing things...
		self.time_since_last_player_action = 0

		self.alien_base_maxhits = 0
				
		# this is reset when you die/start a new level
		# it controls the appearance of the base!
		self.aliens_killed_counter = 0
		# how many aliens you gotta wax before the base shows up?
		self.aliens_killed_required = 0
		self.base_appearance_notification_timer = 0
		self.alien_base_created = 0

		self.fire_triggering_sequence = [0]
		self.fire_triggering_gunheat = 50

		self.rect_distant_despawn = pygame.Rect(0,0,0,0)

		self.using_joy_turret = 0

		self.gun_firing_loop_now = 0
		self.gun_firing_loop_prev = 0

		self.alien_count_tanks = 0

		self.difficulty_minimum_alien_useful = 0

		return

	def addscore(self,points):
		self.score += points
		if self.score >= self.bonus:
			self.ships += 1
			self.bonus += self.boninc
			sound_bonus_ship.play()
		return

STATE = gamestate()

hisc_filename = "dynamaze_highscore.txt"

try:
	hiscfile = open( hisc_filename, "rt")
	try:
		STATE.highscore = int( hiscfile.read())
	except ValueError:
		pass
	hiscfile.close()
except IOError:
	pass

# I'm putting in a high score "floor." Gotta beat this...
if STATE.highscore < 1000:
	STATE.highscore = 1000


##################################################################
xtable32 = []
ytable32 = []

for i in range( MAXROTS):
	angle = (i * 3.1415926 * 2) / MAXROTS
	xm =  int( 65536 * sin( angle))
	ym = -int( 65536 * cos( angle))
#	print "rot = " + `i` + " --> (" + `xm` + "," + `ym` + ")"
	xtable32.append(xm)
	ytable32.append(ym)


##################################################################
atan2_32_table = []

# 02/07/2007 - this is the REFERENCE way to make atan2 tables, so that
# there is no doubling of a wedge across the zero, and no skewing
# of a partial wedge sideways
cx = 25
cy = 25
for j in range( 51):
	oneline = ""
	for i in range( 51):
		angle = atan2( j - cy, i - cx)
		# back out half a pie wedge
		angle = angle + (3.1415926 / MAXROTS)
		# adjust for 90 degrees being top dead center
		angle = angle + (3.1415926 / 2)
		# adjust for sub-zero wrap around (add full 360 degrees)
		if angle < 0:
			angle = angle + 2 * 3.1415926
		iangle = int( (angle * MAXROTS) / (2 * 3.1415926))
		atan2_32_table.append( iangle)
		oneline += chr( 64 + iangle)
#	print oneline


##################################################################
def	atan2_32( x1,y1,x2,y2):
	x = int( x2 - x1)
	y = int( y2 - y1)

	while( (abs(x) > 25) or (abs( y) > 25)):
		x >>= 1
		y >>= 1

	x += 25
	y += 25

	return atan2_32_table[ x + y * 51]

##################################################################
def	stats_paint():
	VGAPRN.setsize(30)
	VGAPRN.color1 = [222,222,222]
	VGAPRN.justify = JUSTIFY_LEFT
	VGAPRN.printf( 10, 5, `STATE.score`)

	# number of lives
	for i in range( STATE.ships):
		x = screen.get_rect().w - 20 - 28 * i
		y = 20
		plot( x, y, your_tank[0])

	if STATE.alien_base_created:
		if STATE.base_appearance_notification_timer > 0:
			VGAPRN.color1 = [255,255,255]
			VGAPRN.justify = JUSTIFY_CENTER
			VGAPRN.printf( screen.get_width() / 2, 70, "ALIEN BASE LOCATED!")

	VGAPRN.color1 = [222,222,222]

	return

##################################################################
# This calls into the maze module, AND it cross-checks against
# other known entities. It sets the .flag to zero if it is
# not able to find a valid spot to spawn, so you should call this
# only AFTER you have set your proposed object's flag to nonzero.
# BUT! we have a hack: we have to zero our flag out first, so we
# do not collide with ourselves endlessly.
def	generate_valid_edge_of_maze_spawn_coords( o, centered):
	o.flag = 0					# preclude self-collision
	for tries in range(5):
		STATE.grid.choose_random_outer_tile_location( o, 1, centered)

		o.calcrect( 50, 50)		# extra large to prevent too-near placements

		# cross-check against goods
		if goods_fast_check_rect( o.r):
			continue

		# cross-check against aliens
		if aliens_fast_check_rect( o.r):
			continue

#		print "We fit the object in!"
		o.flag = 1
		return

#	print "Zeroing out, couldn't fit it"

	return

##################################################################
def	generate_edge_of_screen_coords( o):
	edge = random.randrange( 4)
	if edge == 0:
		o.x = random.randrange( screen.get_width())
		o.y = -20
	elif edge == 1:
		o.x = screen.get_width() + 20
		o.y = random.randrange( screen.get_height())
	elif edge == 2:
		o.x = random.randrange( screen.get_width())
		o.y = screen.get_height() + 20
	else:
		o.x = -20
		o.y = random.randrange( screen.get_height())

	o.rot = atan2_32( o.x, o.y, screen.get_height() / 2, screen.get_width() / 2)

	o.xm = xtable32[ o.rot] * 3
	o.ym = ytable32[ o.rot] * 3

	o.x <<= 16
	o.y <<= 16

	return


##################################################################
def	update_state_bounding_rects():
	if STATE.grid:
		STATE.rect_distant_despawn.x = STATE.grid.bounding_rect.x - 200
		STATE.rect_distant_despawn.y = STATE.grid.bounding_rect.y - 200
		STATE.rect_distant_despawn.w = STATE.grid.bounding_rect.w + 400
		STATE.rect_distant_despawn.h = STATE.grid.bounding_rect.h + 400
	return


##################################################################
def	draw_edge_indicator( o, s):
	ix = o.ix
	iy = o.iy

	need = 0
	if  ix < 15:
		ix = 15
		need = 1
	if ix >= screen.get_width() - 12:
		ix = screen.get_width() - 12
		need = 1
	if  iy < 15:
		iy = 15
		need = 1
	if iy >= screen.get_height() - 20:
		iy = screen.get_height() - 20
		need = 1

	if need:
		VGAPRN.printf( ix - 9, iy - 15, s)

	return


##################################################################
def	draw_edge_arrow_indicator( o):
	ix = o.ix
	iy = o.iy

	need = 0
	if  ix < -40:
		ix = 10
		need = 1
	if ix >= screen.get_width() + 40:
		ix = screen.get_width() - 10
		need = 1
	if  iy < -40:
		iy = 10
		need = 1
	if iy >= screen.get_height() + 40:
		iy = screen.get_height() - 10
		need = 1

	# print "ix = " + `ix` + ", iy = " + `iy` + ", need = " + `need`

	# ix, iy is the arrow point here...
	if need:
		direction = atan2_32( ix, iy, o.ix, o.iy)
		dir1 = (direction - 3) & (MAXROTS - 1)
		dir2 = (direction + 3) & (MAXROTS - 1)

		bouncy = (STATE.canvastimer & 7) * 2

		ix -= (xtable32[direction] * bouncy) >> 16
		iy -= (ytable32[direction] * bouncy) >> 16
		
		# arrow body
		ix2 = ix - ((xtable32[direction] * 50) >> 16)
		iy2 = iy - ((ytable32[direction] * 50) >> 16)
		pygame.draw.line( screen, [255,150,150], (ix, iy), (ix2,iy2), 4)
		# arrow head sides
		ix2 = ix - ((xtable32[dir1] * 16) >> 16)
		iy2 = iy - ((ytable32[dir1] * 16) >> 16)
		pygame.draw.line( screen, [255,150,150], (ix, iy), (ix2,iy2), 4)
		# arrow head sides
		ix2 = ix - ((xtable32[dir2] * 16) >> 16)
		iy2 = iy - ((ytable32[dir2] * 16) >> 16)
		pygame.draw.line( screen, [255,150,150], (ix, iy), (ix2,iy2), 4)

	return

##################################################################
def	colorsets_cls():
	if STATE.current_colorset == 0:
		screen.fill( (0,80,40))
	elif STATE.current_colorset == 1:
		screen.fill( (0,40,90))
	else:
		screen.fill( (60,20,40))
		
	return

##################################################################
# shots module (what the player fires) of Kurt W Dekker's Dynamaze game

##################################################################
SHOTTYPE_BULLET2 = 4002
SHOTTYPE_BULLET3 = 4003

##################################################################
def	shots_clearall():
	STATE.shots = []
	return

def	shots_alloc():
	for s in STATE.shots:
		if s:
			if s.flag == 0:
				s.__init__()
				return s
	s = OBJ()
	STATE.shots.append(s)
	return s

def	shots_think():
	for s in STATE.shots:
		if s:
			if s.flag:
				if s.dead:
					s.flag = 0
					continue

				if s.type == SHOTTYPE_BULLET2:
					s.hits = 2
				elif s.type == SHOTTYPE_BULLET3:
					s.hits = 3
				else:
					print "******** ERROR!!!!! Unknown shottype = " + `s.type`

				s.x -= STATE.you.xm
				s.y -= STATE.you.ym

				for z in range(4):
					s.x += s.xm >> 2
					s.y += s.ym >> 2
					s.calcrect( 8, 8)
					if STATE.grid.collide_rect( s.r, 1):
						s.dead = 1
						break
					a = aliens_fast_check_rect_damage( s.r, s)
					if a:
						# you shot an alien, we'll count that as activity!!
						STATE.time_since_last_player_action -= 20
						a.hits += s.hits
						s.dead = 1
					if s.dead:
						break;

				if	(s.ix < STATE.worldx - 10) or (s.ix > STATE.worldx + screen.get_width() + 10) or \
					(s.iy < STATE.worldy - 10) or (s.iy > STATE.worldy + screen.get_height() + 10):
					s.dead = 1

	return

def	shots_paint():
	numshots = 0
	for s in STATE.shots:
		if s:
			if s.flag:
				## <WIP> this should support different types of shots!
				if s.dead:
					for z in range(4):
						ss_fragments.plot(	s.ix + random.randrange(5) - 2,
											s.iy + random.randrange(5) - 2,
											random.randrange(4))
				else:
					ss_shots_and_bombs.plot( s.ix, s.iy, 0)
					numshots += 1

	STATE.difficulty_curshots = numshots

	return

##################################################################
# bombs module (what aliens fire) of Kurt W Dekker's Dynamaze game

##################################################################
BOMBTYPE_BASIC1	= 3000
BOMBTYPE_MISSILE = 3001

##################################################################
def	bombs_clearall():
	STATE.bombs = []
	return

def	bombs_alloc():
	# cannot fire more bombs once the player dies?
	if STATE.you.dead or not STATE.you.flag:
		return None
	for b in STATE.bombs:
		if b:
			if b.flag == 0:
				b.__init__()
				return b
	b = OBJ()
	STATE.bombs.append(b)
	return b

def	bombs_think():
	for b in STATE.bombs:
		if b:
			if b.flag:
				if b.dead:
					b.flag = 0
					continue

				if b.type == BOMBTYPE_BASIC1:
					pass
				elif b.type == BOMBTYPE_MISSILE:
					pass
				else:
					print "Unknown bombtype!! --> " + `b.type`
					continue

				b.x -= STATE.you.xm
				b.y -= STATE.you.ym

				b.timer += 1
				if b.timer > 100:
					b.flag = 0

				b.animseq += 1
				# cycle back and forth through the 5 available color gradients
				if b.animseq & 4:
					b.frameno = 5 + (b.animseq & 3)
				else:
					b.frameno = 9 - (b.animseq & 3)

				# for all ground-based bombs, check them against walls
				if b.type == BOMBTYPE_BASIC1:
					for z in range(4):
						b.x += b.xm >> 2
						b.y += b.ym >> 2
						b.calcrect( 8, 8)
						if STATE.grid.collide_rect( b.r):
							b.dead = 1
							break
				else:
					b.x += b.xm
					b.y += b.ym
					b.calcrect( 8, 8)

				if	(b.ix < STATE.worldx - 10) or (b.ix > STATE.worldx + screen.get_width() + 10) or \
					(b.iy < STATE.worldy - 10) or (b.iy > STATE.worldy + screen.get_height() + 10):
					b.dead = 1

				if b.r.colliderect( STATE.you.r):
					you_are_dead()
					b.dead = 1

	return

def	bombs_paint():
	numbombs = 0
	for b in STATE.bombs:
		if b:
			if b.flag:
				if b.type == BOMBTYPE_BASIC1:
					ss_shots_and_bombs.plot( b.ix, b.iy, b.frameno)
				elif b.type == BOMBTYPE_MISSILE:
					plot( b.ix, b.iy, bomb_missile[ b.rot])
				numbombs += 1

	STATE.difficulty_curbombs = numbombs

	return

##################################################################
# aliens module of Kurt W Dekker's Dynamaze game

##################################################################
ALIENTYPE_HELI     = 1001
ALIENTYPE_GUNBASE1 = 1002
ALIENTYPE_TANK_RED = 1003
ALIENTYPE_BASE     = 1010

temprect = pygame.Rect(0,0,0,0)

##################################################################
# control the choice of what types of aliens appear. each entry in
# this list is equally likely to be chosen, so you can weight things
# by increasing how many instances of each appear in this list.
alientypechoices = (ALIENTYPE_GUNBASE1, ALIENTYPE_TANK_RED, ALIENTYPE_TANK_RED, ALIENTYPE_TANK_RED)

##################################################################
def	aliens_clearall():
	STATE.aliens = []
	return

def	aliens_alloc():
	for a in STATE.aliens:
		if a:
			if a.flag == 0:
				a.__init__()
				return a
	a = OBJ()
	STATE.aliens.append(a)
	return a

def	aliens_think():
	alien_count_useful = 0
	alien_count_tanks_temp = 0
	for a in STATE.aliens:
		if a:
			if a.flag:
				if a.dead:
					a.x -= STATE.you.xm
					a.y -= STATE.you.ym
					a.calcrect(0,0)
					if a.type == ALIENTYPE_BASE:	# bases explode for a bit
						if a.dead > 40:
							a.flag = 0
							STATE.canvastimer = 0
							STATE.canvasno = CANVAS_ENDWAVE
						if (a.dead & 3) == 1:
							e = expls_alloc()
							if e:
								e.flag = 1
								e.type = EXPLTYPE_40X40_CIRCULAR
								e.x = a.x + ((random.randrange( 50) - 25) << 16)
								e.y = a.y + ((random.randrange( 50) - 25) << 16)
								e.calcrect(0,0)
							sounds_expls[random.randrange(len(sounds_expls))].play()
					else:			# other aliens die immediately
						STATE.aliens_killed_count += 1
						a.flag = 0
					a.dead += 1

					# certain types of aliens leave a crater
					if a.type == ALIENTYPE_GUNBASE1 or a.type == ALIENTYPE_TANK_RED:
						c = craters_alloc()
						if c:
							c.flag = 1
							c.x = a.x
							c.y = a.y
							c.calcrect(0,0)

					continue

				if a.maxhits:
					if a.hits >= a.maxhits:
						a.dead = 1
						if a.type == ALIENTYPE_HELI:
							STATE.addscore( 100)
							sounds_expls[random.randrange(len(sounds_expls))].play()
							for shards in range(10):
								e = expls_alloc()
								if e:
									e.flag = 1
									e.type = EXPLTYPE_BURNING_SHARD
									if random.randrange(2):
										e.type = EXPLTYPE_BLACKENED_SHARD
									e.x = a.x
									e.y = a.y
									e.xm = (random.randrange( 800) - 400) * 655
									e.ym = (random.randrange( 800) - 400) * 655
									e.calcrect(0,0)
						elif a.type == ALIENTYPE_GUNBASE1:
							STATE.addscore(  75)
						elif a.type == ALIENTYPE_TANK_RED:
							# ensure that it didn't just ram a wall!!
							if a.hits:
								STATE.addscore( 150)
						elif a.type == ALIENTYPE_BASE:
							STATE.addscore( 1000 * STATE.wave)
							# drop all shields... the thing blew up
							for i in range(4):
								a.shield_strength[i] = 0
						e = expls_alloc()
						if e:
							e.flag = 1
							e.type = EXPLTYPE_40X40_CIRCULAR
							e.x = a.x
							e.y = a.y
							e.calcrect(0,0)
						if screen.get_rect().colliderect( a.r):
							sounds_expls[random.randrange(len(sounds_expls))].play()
						continue

				## <WIP> this should support different types of aliens!
				if a.type == ALIENTYPE_HELI:
					alien_count_useful += 1
					a.maxhits = 10
					# face towards the player
					a.rot = atan2_32( a.ix, a.iy, STATE.you.ix, STATE.you.iy)
				elif a.type == ALIENTYPE_GUNBASE1:
					alien_count_useful += 1
					a.maxhits = 5
				elif a.type == ALIENTYPE_TANK_RED:
					a.maxhits = 5
					alien_count_useful += 1
					# always have a preferred turn direction
					if a.rotm == 0:
						a.rotm = (random.randrange(2) * 2 - 1) * (2 + random.randrange(3))
					# periodically change direction
					a.timer += 1
					if a.timer > 35:
						a.timer = random.randrange(20)
						if random.randrange( 3):
							a.rot += (random.randrange(2) * 2 - 1) * (1 + random.randrange(2))
							a.rot &= (MAXROTS - 1)
					alien_count_tanks_temp += 1
					a.xm = xtable32[ a.rot] * a.speed
					a.ym = ytable32[ a.rot] * a.speed
					# try to sort of check ahead of you for collisions
					temprect.x = (a.x + a.xm * 3) >> 16
					temprect.y = (a.y + a.ym * 3) >> 16
					# make the check rect a bit fat, to keep you semi-safe
					temprect.x -= 15
					temprect.y -= 15
					temprect.w  = 30
					temprect.h  = 30
					# stop and turn in place until you're clear
					if STATE.grid.collide_rect( temprect):
						a.xm = 0
						a.ym = 0
						a.rot += a.rotm
						a.rot &= (MAXROTS - 1)
				elif a.type == ALIENTYPE_BASE:
					a.maxhits = STATE.alien_base_maxhits
					if STATE.alien_count_tanks < 5:		# <WIP> key this to a "difficulty" setting
						# periodically spawn a tank alien!
						if a.gunheat > 0:
							a.gunheat -= 1
							if a.gunheat == 0:
								a2 = aliens_alloc()
								if a2:
									a2.flag = 1
									a2.type = ALIENTYPE_TANK_RED
									a2.gunheat = 1 + random.randrange(30)
									a2.x = a.x
									a2.y = a.y
									a2.calcrect(20,20)
									# go towards the player
									a2.rot = atan2_32( a2.ix, a2.iy, STATE.you.ix, STATE.you.iy)
									# but only on pure compass direction
									a2.rot &= 24
									a2.speed = 4
						else:
							a.gunheat = STATE.fire_triggering_gunheat + random.randrange(STATE.fire_triggering_gunheat)
				else:
					print "Unknown alien type!!! a.type --> " + `a.type`
					continue

				a.x -= STATE.you.xm
				a.y -= STATE.you.ym

				a.x += a.xm
				a.y += a.ym
				a.calcrect( 25, 25)

				# only truly mobile aliens should bother checking the maze grid
				if a.type == ALIENTYPE_TANK_RED:
					if STATE.grid.collide_rect( a.r, 25):
						# this reverse combination means "player did not score points"
						a.hits = 0
						a.maxhits = -1

				if a.type == ALIENTYPE_BASE:
					a.shields[0].x = a.ix - 40
					a.shields[0].y = a.iy - 45
					a.shields[0].w = 80
					a.shields[0].h = 10
					a.shields[1].x = a.ix + 35
					a.shields[1].y = a.iy - 40
					a.shields[1].w = 10
					a.shields[1].h = 80
					a.shields[2].x = a.ix - 40
					a.shields[2].y = a.iy + 35
					a.shields[2].w = 80
					a.shields[2].h = 10
					a.shields[3].x = a.ix - 45
					a.shields[3].y = a.iy - 40
					a.shields[3].w = 10
					a.shields[3].h = 80

				# <WIP> prevent aliens from walking through walls

				# kill aliens off that are too far away
				if not STATE.rect_distant_despawn.collidepoint( a.ix, a.iy):
					# print "Despawning a distant alien!"
					a.flag = 0
					if a.type == ALIENTYPE_BASE:
						STATE.alien_base_created = 0
					continue


#				if STATE.grid.collide_rect( a.r):
#					a.dead = 1
#					continue

#				if	(a.ix < STATE.worldx - 10) or (a.ix > STATE.worldx + screen.get_width() + 10) or \
#					(a.iy < STATE.worldy - 10) or (a.iy > STATE.worldy + screen.get_height() + 10):
#					a.dead = 1

				if (a.type == ALIENTYPE_GUNBASE1) or (a.type == ALIENTYPE_TANK_RED):
					if a.gunheat > 0:
						a.gunheat -= 1
						if a.gunheat in STATE.fire_triggering_sequence:
							# only fire if onscreen
							if a.r.colliderect( screen.get_rect()):
								b = bombs_alloc()
								if b:
									b.flag = 1
									b.type = BOMBTYPE_BASIC1

									b.x = a.x
									b.y = a.y

									# we're going to do a funky half-precision 16.16 fixed-point
									# calculation to avoid overflowing a 32bit int
									b.xm = (STATE.you.x - b.x) >> 8
									b.ym = (STATE.you.y - b.y) >> 8
									dist = int( sqrt( b.xm * b.xm + b.ym * b.ym))

									# <WIP> document and convert this mathematical mess into standard
									# 100ths of a pixel speed or something similarly useful!!
									if dist > 0:
										bombspeed = 1200 + STATE.bomb_speed_bonus
										b.xm = (bombspeed * 256 * b.xm) / dist
										b.ym = (bombspeed * 256 * b.ym) / dist

									b.calcrect( 0,0)

									sound_bomb_basic1.play()
					else:
						a.gunheat = STATE.fire_triggering_gunheat + random.randrange(10)

				if a.type == ALIENTYPE_HELI:
					if a.gunheat > 0:
						# only fire if you're not "too close" to the player - be nice!!
						if (abs( STATE.you.ix - a.ix) + abs( STATE.you.iy - a.iy)) > 110:
							a.gunheat -= 1
							if a.gunheat == 0:
								if a.r.colliderect( screen.get_rect()):
									b = bombs_alloc()
									if b:
										b.flag = 1
										b.type = BOMBTYPE_MISSILE

										b.x = a.x
										b.y = a.y

										b.rot = a.rot

										b.xm = (xtable32[ b.rot] >> 8) * (6 * 256 + STATE.bomb_speed_bonus)
										b.ym = (ytable32[ b.rot] >> 8) * (6 * 256 + STATE.bomb_speed_bonus)

										b.calcrect( 0,0)

										sound_bomb_missile.play()
					else:
						a.gunheat = STATE.fire_triggering_gunheat + random.randrange(10)

				# if you ram an alien base's shields, you're toast
				if	a.type == ALIENTYPE_BASE:
					for iii in range(4):
						if a.shield_strength[iii] > 0:
							if a.shields[iii].colliderect( STATE.you.r):
								you_are_dead()

				if	(a.type == ALIENTYPE_GUNBASE1) or \
					(a.type == ALIENTYPE_TANK_RED) or \
					(a.type == ALIENTYPE_BASE):
					if a.r.colliderect( STATE.you.r):
						you_are_dead()
						a.dead = 1

	STATE.alien_count_tanks = alien_count_tanks_temp

	STATE.time_since_last_player_action += 1

	# if you are screwing around too much, then you get helicopters attacking!
	helicopter_interval = 255
	if STATE.time_since_last_player_action >= 200:
		helicopter_interval = 127
	elif STATE.time_since_last_player_action >= 300:
		helicopter_interval =  63

	# periodically add a helicopter in at the edge!!
	if (STATE.canvastimer & helicopter_interval) == 0:
		a = aliens_alloc()
		if a:
			a.flag = 1
			a.type = ALIENTYPE_HELI

			generate_edge_of_screen_coords(a)

			a.calcrect(0,0)

	if STATE.base_appearance_notification_timer > 0:
		STATE.base_appearance_notification_timer -= 1

	# periodically spawn other types of aliens for testnig
	if (alien_count_useful < STATE.difficulty_minimum_alien_useful) or (random.randrange( 50) == 0):
		a = aliens_alloc()
		if a:
			a.flag = 1

			a.type = alientypechoices[ random.randrange( len( alientypechoices))]

			a.speed = 4

			if STATE.aliens_killed_count >= STATE.aliens_killed_required:
				if not STATE.alien_base_created:
					if random.randrange(3) == 0:
						STATE.base_appearance_notification_timer = 50

						STATE.alien_base_created = a

						# special stuff for the alien base
						a.type = ALIENTYPE_BASE
						a.shields = []
						a.shields.append( pygame.Rect( 0,0,0,0))
						a.shields.append( pygame.Rect( 0,0,0,0))
						a.shields.append( pygame.Rect( 0,0,0,0))
						a.shields.append( pygame.Rect( 0,0,0,0))
						a.shield_strength = []
						a.shield_strength.append( 200)
						a.shield_strength.append( 200)
						a.shield_strength.append( 200)
						a.shield_strength.append( 200)

						if STATE.wave_accelerator == 0:
							STATE.wave_accelerator = 1

			a.x = (screen.get_width() + 20) << 16
			a.y = (40 + random.randrange( screen.get_height() - 80)) << 16

			a.xm = -3 << 16
			a.ym = ((screen.get_height() << 15) - a.y) >> 6

			if a.type == ALIENTYPE_BASE:
				generate_valid_edge_of_maze_spawn_coords( a, 1)
				if not a.flag:
					STATE.alien_base_created = 0		# never mind
			else:
				generate_valid_edge_of_maze_spawn_coords( a, 0)

			a.xm = 0
			a.ym = 0

			a.calcrect(0,0)

			# print "New alien at (" + `a.ix` + "," + `a.iy` + ")"

			# printrect( STATE.grid.bounding_rect, "Grid Bounds:")

	# if you've been screwing around too long, things start to get nasty!
	if STATE.wave_accelerator > 0:
		STATE.wave_accelerator += 1
		if STATE.wave_accelerator > 800:
			STATE.bomb_speed_bonus = STATE.wave_accelerator - 800
	else:
		STATE.bomb_speed_bonus = 0

	return

def	aliens_paint( airborne):
	groundborne = not airborne
	numaliens = 0
	for a in STATE.aliens:
		if a:
			if a.flag:
				numaliens += 1
				if a.type == ALIENTYPE_HELI:
					if airborne:
						plot( a.ix, a.iy, helicopter_body[ a.rot])
						plot( a.ix, a.iy, helicopter_blades[ STATE.canvastimer & 15])
					if groundborne:
						# shadow is slightly offset from the helicopter itself
						plot( a.ix + 30, a.iy + 30, helicopter_shadow[ a.rot])
				elif a.type == ALIENTYPE_GUNBASE1:
					if groundborne:
						plot( a.ix, a.iy, alien_gunbase1)
				elif a.type == ALIENTYPE_TANK_RED:
					if groundborne:
						plot( a.ix + 4, a.iy + 4, your_tank_shadow[ a.rot])
						plot( a.ix, a.iy, alien_tank_red[ a.rot])
				elif a.type == ALIENTYPE_BASE:
					if groundborne:
						plot( a.ix, a.iy, alien_base_center)
						draw_edge_arrow_indicator(a)
						for iii in range(4):
							if a.shield_strength[iii] > 0:
								intensity = 30 + 1 * a.shield_strength[iii]
								pygame.draw.rect( screen, [intensity, intensity, intensity], a.shields[iii])

				# draw_edge_indicator( a, "a")

	STATE.difficulty_curaliens = numaliens

	return

# this is used for inter-alien collision when placing new aliens
def	aliens_fast_check_rect( r):
	for a in STATE.aliens:
		if a:
			if a.flag:
				if a.type == ALIENTYPE_BASE:
					bigger_rect = a.r.inflate( 50, 50)
					if bigger_rect.colliderect( r):
						return a
				if a.r.colliderect( r):
					return a
	return None

def	aliens_fast_check_rect_damage( r, shot):
	for a in STATE.aliens:
		if a:
			if a.flag:
				if a.type == ALIENTYPE_BASE:
					for i in range(4):
						if a.shield_strength[i] > 0:
							if a.shields[i].colliderect( r):
								a.shield_strength[i] -= shot.hits
								shot.dead = 1
								# you didn't hit the alien, you hit its shield
								return None
				if a.r.colliderect( r):
					return a
	return None

##################################################################
#
# as of release 0.2 there are no goods that get spawned anymore...
#

GOODTYPE_COIN = 2000
GOODTYPE_AMMO = 2001
GOODTYPE_BOMB = 2002


##################################################################
def	goods_clearall():
	STATE.goods = []
	return

def	goods_alloc():
	for g in STATE.goods:
		if g:
			if g.flag == 0:
				g.__init__()
				return g
	g = OBJ()
	STATE.goods.append(g)
	return g

def	goods_think():
	for g in STATE.goods:
		if g:
			if g.flag:
				if g.dead:
					# <WIP> how about a shower of sparks or a twinkle?
					g.flag = 0
					continue

				## <WIP> this should support different types of goods!

				g.x -= STATE.you.xm
				g.y -= STATE.you.ym

				g.x += g.xm
				g.y += g.ym
				g.calcrect( 25, 25)

				# <WIP> prevent goods from walking through walls

				# kill goods off that are too far away
				if not STATE.rect_distant_despawn.collidepoint( g.ix, g.iy):
#					print "Despawning a distant good!"
					g.flag = 0
					continue


#				if STATE.grid.collide_rect( g.r):
#					g.dead = 1
#					continue

#				if	(g.ix < STATE.worldx - 10) or (g.ix > STATE.worldx + screen.get_width() + 10) or \
#					(g.iy < STATE.worldy - 10) or (g.iy > STATE.worldy + screen.get_height() + 10):
#					g.dead = 1

	# turning off coins; they are too incongruous for the game!!
	if 0:
		# periodically spawn in a coin at the edges
		if random.randrange( 50) == 0:
			g = goods_alloc()
			if g:
				g.flag = 1
				g.type = GOODTYPE_COIN

				g.x = (screen.get_width() + 20) << 16
				g.y = (40 + random.randrange( screen.get_height() - 80)) << 16

				g.xm = -3 << 16
				g.ym = ((screen.get_height() << 15) - g.y) >> 6

				generate_valid_edge_of_maze_spawn_coords( g, 0)

				g.xm = 0
				g.ym = 0

				g.calcrect(20,20)

				# print "New good at (" + `g.ix` + "," + `g.iy` + ")"

				# printrect( STATE.grid.bounding_rect, "Grid Bounds:")

	return

def	goods_paint():
	numgoods = 0
	for g in STATE.goods:
		if g:
			if g.flag:
				numgoods += 1
					
				# draw_edge_indicator( g, "g")

	STATE.difficulty_curgoods = numgoods

	return


def	goods_fast_check_rect( r):
	for g in STATE.goods:
		if g:
			if g.flag:
				if g.r.colliderect( r):
					return g
	return None

##################################################################
EXPLTYPE_40X40_CIRCULAR = 5000
EXPLTYPE_BURNING_SHARD  = 5001
EXPLTYPE_BLACKENED_SHARD  = 5002

##################################################################
def	expls_clearall():
	STATE.expls = []
	return

def	expls_alloc():
	for e in STATE.expls:
		if e:
			if e.flag == 0:
				e.__init__()
				return e
	e = OBJ()
	STATE.expls.append(e)
	return e

def	expls_think():
	for e in STATE.expls:
		if e:
			if e.flag:
				if e.type == EXPLTYPE_40X40_CIRCULAR:
					e.timer += 1
					e.frameno = e.timer - 1
					if e.timer > 10:
						e.flag = 0
						continue
				elif (e.type == EXPLTYPE_BURNING_SHARD) or (e.type == EXPLTYPE_BLACKENED_SHARD):
					if e.rotm == 0:
						e.rotm = (random.randrange( 2) * 2 - 1) * (1 + random.randrange(4))
					e.rot = (e.rot + e.rotm) & (MAXROTS - 1)
					e.timer += 1
					if e.timer >= 5 + random.randrange(30):
						e.flag = 0
						continue
				else:
					print "Unknown expltype!! --> " + `e.type`
					continue

				e.x -= STATE.you.xm
				e.y -= STATE.you.ym

				e.x += e.xm
				e.y += e.ym
				e.calcrect( 0, 0)
	return

def	expls_paint():
	for e in STATE.expls:
		if e:
			if e.flag:
				if e.type == EXPLTYPE_40X40_CIRCULAR:
					ss_expls_40x40_circular.plot( e.ix, e.iy, e.frameno)
				elif e.type == EXPLTYPE_BURNING_SHARD:
					red = 150 + random.randrange( 50)
					green = 100 + random.randrange( 50)
					pygame.draw.line( screen, [red, green, 0], (e.ix, e.iy),
										(e.ix + ((xtable32[ e.rot] * 10) >> 16), e.iy + ((ytable32[ e.rot] * 10) >> 16)),
										3)
				elif e.type == EXPLTYPE_BLACKENED_SHARD:
					pygame.draw.line( screen, [0,0, 0], (e.ix, e.iy),
										(e.ix + ((xtable32[ e.rot] * 10) >> 16), e.iy + ((ytable32[ e.rot] * 10) >> 16)),
										3)

	return

##################################################################
# to keep things from bogging down horribly!!
MAXCRATERS = 8

crater_reallocation_rover = 0

##################################################################
def	craters_clearall():
	STATE.craters = []
	return

def	craters_alloc():
	global crater_reallocation_rover
	# if we have too many, we recycle ones we have
	if len( STATE.craters) >= MAXCRATERS:
		c = STATE.craters[crater_reallocation_rover]
		crater_reallocation_rover += 1
		if crater_reallocation_rover >= len( STATE.craters):
			crater_reallocation_rover = 0
		c.__init__()
		return c

	for c in STATE.craters:
		if c:
			if c.flag == 0:
				c.__init__()
				return c
	c = OBJ()
	STATE.craters.append(c)
	return c

def	craters_think():
	for c in STATE.craters:
		if c:
			if c.flag:
				if c.dead:
					c.flag = 0
					continue

				c.x -= STATE.you.xm
				c.y -= STATE.you.ym

				c.calcrect( 40, 40)

				# kill craters off that are too far away
				if not screen.get_rect().colliderect( c.r):
					# print "Despawning a distant crater!"
					c.flag = 0
					continue

	return

def	craters_paint():
	for c in STATE.craters:
		if c:
			if c.flag:
				ss_craters.plot( c.ix, c.iy, 0)
	return

##################################################################
# dynamic maze module of Kurt W Dekker's Dynamaze game

##################################################################
WALLTYPE_BASIC = 1
WALLTYPE_LIGHTNING = 2

WALLATTRIB_BOUNCY = 0x0001


##################################################################
posswalls = ( 0, 0, 0, 2, 2, 4, 4, 6)

def	wallmaker():
	return posswalls[ random.randrange( len( posswalls))]

def	generate_random_cell_walls( c):
	c.wallbits = wallmaker()
#	c.eastwall.walltype = posswalltypes[ random.randrange( len( posswalltypes))]
	c.eastwall.hits = 0
#	c.southwall.walltype = posswalltypes[ random.randrange( len( posswalltypes))]
	c.southwall.hits = 0
	return

def	walldrawer( w):
	pygame.draw.rect( screen, w.color, w.r)
	return

class	WALL:
	def	__init__(self):
		self.walltype = WALLTYPE_BASIC
		self.color = [ 255, 255, 255]
		self.attribs = 0
		self.r = pygame.Rect(0,0,0,0)
		self.maxhits = 100
		self.hits = 0
		self.react = 0			# flashes
		return
	def	apply_damage(self, damage):
		if not damage:
			return
		self.hits += damage
		self.react = 3
		return
	def think(self):
		if STATE.current_colorset == 0:
			self.color = [  80, 200,  80]
		elif STATE.current_colorset == 1:
			self.color = [  80,  80, 200]
		else:
			self.color = [ 150,  20,  80]
		if self.react > 0:
			if STATE.current_colorset == 0:
				self.color = [ 150, 200, 150]
			elif STATE.current_colorset == 1:
				self.color = [ 150, 150, 250]
			else:
				self.color = [ 200,  70, 120]
			self.react -= 1
		if self.hits >= self.maxhits:
			sounds_expls[random.randrange(len(sounds_expls))].play()
			if self.r.w > self.r.h:
				for i in range(10):
					e = expls_alloc()
					if e:
						e.flag = 1
						e.type = EXPLTYPE_BURNING_SHARD
						e.x = (self.r.x + (self.r.w * i) / 10) << 16
						e.y = (self.r.y + random.randrange( self.r.h)) << 16
						e.xm = (random.randrange( 400) - 200) * 655
						e.ym = (random.randrange( 400) - 200) * 655
						e.calcrect(0,0)
			else:
				for i in range(10):
					e = expls_alloc()
					if e:
						e.flag = 1
						e.type = EXPLTYPE_BURNING_SHARD
						e.x = (self.r.x + random.randrange( self.r.w)) << 16
						e.y = (self.r.y + (self.r.h * i) / 10) << 16
						e.xm = (random.randrange( 400) - 200) * 655
						e.ym = (random.randrange( 400) - 200) * 655
						e.calcrect(0,0)
			return 1
		return 0

class	CELL:
	def	__init__(self):
		self.x = 0
		self.y = 0
		self.wallbits = 0
		self.southwall = WALL()
		self.eastwall = WALL()
		return

class	DYNAMAZE:
	def	__init__(self,xtiles,ytiles,tilexsz,tileysz,screenxsz,screenysz):
		self.roverside = -1
		self.rovermark = -1
		self.xxx = 0				# the nominal "position" of this maze in 16.16 space
		self.yyy = 0
		self.ixxx = 0				# the integer "position" derived from above (xxx,yyy)
		self.iyyy = 0
		self.xtiles = xtiles		# how many tile cells across and down?
		self.ytiles = ytiles
		self.tilexsz = tilexsz		# how big are the tile cells?
		self.tileysz = tileysz
		self.screenxsz = screenxsz	# for calculating display metrics
		self.screenysz = screenysz
		self.cells = []
		self.bounding_rect = pygame.Rect(0,0,0,0)
		self.screen_rect = pygame.Rect( (xtiles * tilexsz - screen.get_width()) / 2,
										(ytiles * tileysz - screen.get_height()) / 2,
										screen.get_width(), screen.get_height())

		deadzonerect = self.screen_rect.inflate( -50, -50)

		for j in range( self.ytiles):
			for i in range( self.xtiles):
				c = CELL()
				c.x = i * self.tilexsz
				c.y = j * self.tileysz
				# the center area is clear, the outer area MAY be walled, but
				# at a distance far enough to allow you to scroll it to the outer
				# regenerative area, which will stave off being locked in
				if (deadzonerect.collidepoint( c.x + tilexsz / 2, c.y + tileysz / 2)):
					c.wallbits = 0
				else:
					generate_random_cell_walls( c)
				self.cells.append( c)
		return

	# this roves the maze perimeter, changing the tiles found there, just to
	# ensure that you cannot get trapped indefinitely, and to stir the pot a bit
	def	rover_changer(self):
		if self.rovermark < 0:
			self.roverside = (self.roverside + 1) & 3
			self.rovermark = 0
		if self.roverside == 0:			# top edge
			generate_random_cell_walls( self.cells[ self.rovermark])
			self.rovermark += 1
			if self.rovermark >= self.xtiles:
				self.rovermark = -1
		elif self.roverside == 1:		# right edge
			generate_random_cell_walls( self.cells[ (self.xtiles - 1) + self.xtiles * self.rovermark])
			self.rovermark += 1
			if self.rovermark >= self.ytiles:
				self.rovermark = -1
		elif self.roverside == 2:		# bottom edge
			generate_random_cell_walls( self.cells[ self.xtiles * (self.ytiles - 1) + self.rovermark])
			self.rovermark += 1
			if self.rovermark >= self.xtiles:
				self.rovermark = -1
		elif self.roverside == 3:		# left edge
			generate_random_cell_walls( self.cells[ self.xtiles * self.rovermark])
			self.rovermark += 1
			if self.rovermark >= self.ytiles:
				self.rovermark = -1
		return

	# this paint() call is used both during the scroll in order to set the
	# individual wall rects up to their new location, and then during the
	# actual paint those rectangles are used to generate the graphics.
	def	paint(self,dopaint=1):
		n = 0
		ulx = self.ixxx + ((self.screenxsz - self.xtiles * self.tilexsz) >> 1)
		uly = self.iyyy + ((self.screenysz - self.ytiles * self.tileysz) >> 1)
		for j in range( self.ytiles):
			for i in range( self.xtiles):
				c = self.cells[n]
				n += 1

				if c.wallbits & 2:		# east
					if dopaint:
						walldrawer( c.eastwall)
					else:
						c.eastwall.r.x = c.x + self.tilexsz - 4 + ulx
						c.eastwall.r.y = c.y + uly
						c.eastwall.r.w = 8
						c.eastwall.r.h = self.tileysz
						c.eastwall.r.clip( screen.get_rect())
						if c.eastwall.think():
							c.wallbits &= ~2
				else:
					c.eastwall.r.w = 0		# no collision

				if c.wallbits & 4:		# south
					if dopaint:
						walldrawer( c.southwall)
					else:
						c.southwall.r.x = c.x + ulx
						c.southwall.r.y = c.y + self.tileysz - 4 + uly
						c.southwall.r.w = self.tilexsz
						c.southwall.r.h = 8
						c.southwall.r.clip( screen.get_rect())
						if c.southwall.think():
							c.wallbits &= ~4
				else:
					c.southwall.r.w = 0		# no collision

	def	shift_cell_contents(self, dest, source):
		self.cells[dest].wallbits = self.cells[source].wallbits
		self.cells[dest].southwall.walltype = self.cells[source].southwall.walltype
		self.cells[dest].southwall.hits     = self.cells[source].southwall.hits
		self.cells[dest].southwall.maxhits  = self.cells[source].southwall.maxhits
		self.cells[dest].eastwall.walltype  = self.cells[source].eastwall.walltype
		self.cells[dest].eastwall.hits      = self.cells[source].eastwall.hits
		self.cells[dest].eastwall.maxhits   = self.cells[source].eastwall.maxhits
		return

	def scroll(self,xm,ym):
		self.xxx += xm
		self.yyy += ym
		newx = self.xxx >> 16
		newy = self.yyy >> 16
		# detect cell edge transitions in order to:
		# 1- shift all cells in the direction of motion
		# 2- generate new cells at the edge
		if xm < 0:
			if newx < 0:
				newx += self.tilexsz
				self.xxx += self.tilexsz << 16
				n = 0
				for j in range( self.ytiles):
					for i in range( self.xtiles - 1):
						self.shift_cell_contents( n, n + 1)
						n += 1
					generate_random_cell_walls( self.cells[n])
					n += 1
		if xm > 0:
			if newx >= self.tilexsz:
				newx -= self.tilexsz
				self.xxx -= self.tilexsz << 16
				for j in range( self.ytiles):
					n = j * self.xtiles + self.xtiles - 1
					for i in range( self.xtiles - 1):
						self.shift_cell_contents( n, n - 1)
						n -= 1
					generate_random_cell_walls( self.cells[n])
		if ym < 0:
			if newy < 0:
				newy += self.tileysz
				self.yyy += self.tileysz << 16
				n = 0
				for j in range( self.ytiles - 1):
					for i in range( self.xtiles):
						self.shift_cell_contents( n, n + self.xtiles)
						n += 1
				for i in range( self.xtiles):
					generate_random_cell_walls( self.cells[n])
					n += 1
		if ym > 0:
			if newy >= self.tileysz:
				newy -= self.tileysz
				self.yyy -= self.tileysz << 16
				for i in range( self.xtiles):
					n = self.xtiles * (self.ytiles - 1) + i
					for j in range( self.ytiles - 1):
						self.shift_cell_contents( n, n - self.xtiles)
						n -= self.xtiles
					generate_random_cell_walls( self.cells[n])

		self.ixxx = newx
		self.iyyy = newy

		self.bounding_rect.x = self.ixxx + ((self.screenxsz - self.xtiles * self.tilexsz) >> 1)
		self.bounding_rect.y = self.iyyy + ((self.screenysz - self.ytiles * self.tileysz) >> 1)

		self.bounding_rect.w = self.xtiles * self.tilexsz
		self.bounding_rect.h = self.ytiles * self.tileysz

		self.paint(0)		# just to update the rects

		return

	def collide_rect( self, r, damage = 0):
		# figure out which cells we actually have to consider for collision
		tileulx = int( (r.x - self.bounding_rect.x - (self.tilexsz >> 1)) / self.tilexsz)
		tileuly = int( (r.y - self.bounding_rect.y - (self.tileysz >> 1)) / self.tileysz)

		if tileulx < 0:
			tileulx = 0
		if tileulx >= self.xtiles - 1:
			tileulx = self.xtiles - 2
		if tileuly < 0:
			tileuly = 0
		if tileuly >= self.ytiles - 1:
			tileuly = self.ytiles - 2

		for j in range( 2):
			for i in range( 2):
				n = i + tileulx + (j + tileuly) * self.xtiles
				if (n >= 0) and (n < self.xtiles * self.ytiles):
					c = self.cells[ n]
					if c.southwall.r.w:
						if c.southwall.r.colliderect( r):
							c.southwall.apply_damage( damage)
							return 1
					if c.eastwall.r.w:
						if c.eastwall.r.colliderect( r):
							c.eastwall.apply_damage( damage)
							return 1
		return 0

	# Nobody should use this outside of wrappers such as the one
	# in STATE that actually check for collisions!
	def	choose_random_outer_tile_location(self,o,playerwards=1,centered=1):
		# do we choose this in the direction the player is moving, or randomly?
		if playerwards:
			edge = STATE.you.rot
			
			# adjust for the 1/16th rotation implied by my 8-skewed edges below
			edge -= MAXROTS / 16

			# perturb the chosen direction slightly
			edge += random.randrange( MAXROTS / 8)

			# convert from maxrots == 32 down to edges == 8 (8 skewed by 16th of a rotation)
			edge >>= 2

			edge &= 7

			# print "you.rot = " + `STATE.you.rot` + ", chosen edge = " + `edge`
		else:
			edge = random.randrange(8)

		if edge == 7:
			x = random.randrange( self.xtiles / 2)
			y = 0
		elif edge == 0:
			x = self.xtiles / 2 + random.randrange( self.xtiles / 2)
			y = 0
		elif edge == 1:
			x = self.xtiles - 1
			y = random.randrange( self.ytiles / 2)
		elif edge == 2:
			x = self.xtiles - 1
			y = self.ytiles / 2 + random.randrange( self.ytiles / 2)
		elif edge == 3:
			x = self.xtiles / 2 + random.randrange( self.xtiles / 2)
			y = self.ytiles - 1
		elif edge == 4:
			x = random.randrange( self.xtiles / 2)
			y = self.ytiles - 1
		elif edge == 5:
			x = 0
			y = self.ytiles / 2 + random.randrange( self.ytiles / 2)
		elif edge == 6:
			x = 0
			y = random.randrange( self.ytiles / 2)
		
		# now calculate the tile spot we've chosen into actual world coords
		o.ix = self.ixxx + x * self.tilexsz + ((self.screenxsz - self.xtiles * self.tilexsz) >> 1)
		o.iy = self.iyyy + y * self.tileysz + ((self.screenysz - self.ytiles * self.tileysz) >> 1)

		if centered:		# center of tile please (keeps us from wall problems right off the bat)
			o.ix += self.tilexsz / 2
			o.iy += self.tileysz / 2
		else:				# or rather center-ish (perturbed within central-ish region)
			o.ix += self.tilexsz / 4 + random.randrange( self.tilexsz / 2)
			o.iy += self.tileysz / 4 + random.randrange( self.tileysz / 2)

		# translate up to 16.16 fixed point
		o.x = o.ix << 16
		o.y = o.iy << 16

		return

##################################################################
def you_think():
	u = STATE.you
	g = STATE.gun

	u.xm = 0
	u.ym = 0

	if not u.flag:
		if STATE.ships > 0:
			STATE.ships -= 1
			STATE.you.__init__()

			u.flag = 1

			init_inityoustart()

		else:
			STATE.canvasno = CANVAS_GREET
			return

	if u.dead:
		u.dead += 1
		if (u.dead & 7) == 2:
			e = expls_alloc()
			if e:
				e.flag = 1
				e.type = EXPLTYPE_40X40_CIRCULAR
				e.x = u.x + ((random.randrange( 30) - 15) << 16)
				e.y = u.y + ((random.randrange( 30) - 15) << 16)
			sounds_expls[random.randrange(len(sounds_expls))].play()
		if u.dead > 50:
			u.dead = 0
			u.flag = 0
		return


	joystick_think()

	your_shot_speed = 20

	your_speed = 5
	gun_length = 16

	g.speed = 0			# actually means "not firing"

	u.speed = 0

	if jx1 != -1 and jy1 != -1:
		if	(abs( jx1 - 100) > joystick_dead_zone) or (abs( jy1 - 100) > joystick_dead_zone):
			u.rot = atan2_32( 100, 100, jx1, jy1)
			u.speed = your_speed
			u.xm = (xtable32[ u.rot] * u.speed)
			u.ym = (ytable32[ u.rot] * u.speed)

	key_input = 0
	if keybits[K_LEFT]:
		STATE.using_joy_turret = 0
		u.xm = -your_speed << 16
		key_input = 1
	if keybits[K_RIGHT]:
		STATE.using_joy_turret = 0
		u.xm =  your_speed << 16
		key_input = 1
	if keybits[K_UP]:
		STATE.using_joy_turret = 0
		u.ym = -your_speed << 16
		key_input = 1
	if keybits[K_DOWN]:
		STATE.using_joy_turret = 0
		u.ym =  your_speed << 16
		key_input = 1
	if key_input:
		u.rot = atan2_32( 0, 0, u.xm, u.ym)


	if STATE.using_joy_turret == 0:
		g.xm = 0
		g.ym = 0

	key_input2 = 0			# recycling for a second check of keyboard gun control

	# how about possibly FIRING with the WASD keys?
	if keybits[K_a]:
		STATE.using_joy_turret = 0
		g.xm = -gun_length
		g.speed = gun_length
		key_input2 = 1
	if keybits[K_d]:
		STATE.using_joy_turret = 0
		g.xm =  gun_length
		g.speed = gun_length
		key_input2 = 1
	if keybits[K_w]:
		STATE.using_joy_turret = 0
		g.ym = -gun_length
		g.speed = gun_length
		key_input2 = 1
	if keybits[K_s]:
		STATE.using_joy_turret = 0
		g.ym =  gun_length
		g.speed = gun_length
		key_input2 = 1

	# if there is a second joystick controller, use it
	if (jx2 != -1) and (jy2 != -1) and \
		((abs( jx2 - 100) > joystick_dead_zone) or (abs( jy2 - 100) > joystick_dead_zone)):
		g.rot = atan2_32( 100, 100, jx2, jy2)
		g.speed = gun_length
		g.xm = (xtable32[ g.rot] * gun_length) >> 16
		g.ym = (ytable32[ g.rot] * gun_length) >> 16

		STATE.using_joy_turret = 1

	# otherwise your turret should follow your nose
	# (with the possible exception of independent fire direction keyboard control?)
	if (STATE.using_joy_turret == 0):
		if key_input2:
			g.rot = atan2_32( 0, 0, g.xm, g.ym)
		else:
			g.rot = u.rot
		g.xm = (xtable32[ g.rot] * gun_length) >> 16
		g.ym = (ytable32[ g.rot] * gun_length) >> 16


	if keybits[ K_LCTRL] or keybits[ K_RCTRL] or (jbuttons & 15):
		g.speed = gun_length

	STATE.gun_firing_loop_now = 0

	u.x = (scrx >> 1) << 16;
	u.y = (scry >> 1) << 16;

	u.calcrect( 20, 20)

	STATE.grid.scroll( -u.xm, -u.ym)

	if g.speed:
		# fire a shot!
		s = shots_alloc()
		if s:
			s.flag = 1
			s.type = SHOTTYPE_BULLET2
			s.x = u.x
			s.y = u.y
			s.xm = (xtable32[ g.rot] * your_shot_speed)
			s.ym = (ytable32[ g.rot] * your_shot_speed)
			s.xm += (random.randrange( 400) - 200) * 655
			s.ym += (random.randrange( 400) - 200) * 655
			STATE.gun_firing_loop_now = 1

	# edge detect
	if STATE.gun_firing_loop_now != STATE.gun_firing_loop_prev:
		if STATE.gun_firing_loop_now:
			sound_gun_firing_loop.play(-1)
		else:
			sound_gun_firing_loop.stop()
		STATE.gun_firing_loop_prev = STATE.gun_firing_loop_now

	# check you against maze walls, kablooie
	if STATE.grid.collide_rect( u.r):
		u.dead = 1

	# turned off goods 02/17/2007
	if 0:
		# check you against goods... collect 'em all!
		o = goods_fast_check_rect( u.r)
		if o and o.flag:
			# collecting goods buys you a little bit of time
			STATE.time_since_last_player_action -= 30
			if o.type == GOODTYPE_COIN:
				STATE.addscore( 25)
				o.dead = 1

	if STATE.time_since_last_player_action < 0:
		STATE.time_since_last_player_action = 0

	return


def	you_paint():
	u = STATE.you
	g = STATE.gun

	if (not u.flag) or u.dead:
		return

	plot( u.ix + 4, u.iy + 4, your_tank_shadow[ u.rot])
	plot( u.ix, u.iy, your_tank[ u.rot])
	plot( u.ix, u.iy, your_tank_turret)

	pygame.draw.line( screen, [255,255,0], (u.ix, u.iy), (u.ix + g.xm, u.iy + g.ym), 3)

	return


def	you_are_dead():
	sound_gun_firing_loop.stop()
	u = STATE.you
	if u.dead:
		return
	u.dead = 1
	return

##################################################################
# init module of Kurt W Dekker's Dynamaze game

##################################################################
def	init_initgame():
	STATE.wave = 0
	STATE.score = 0
	STATE.ships = 4
	STATE.cheating = 0

	STATE.bonus = 10000
	STATE.boninc = 10000

	STATE.you.__init__()

	return


##################################################################
def	init_initwave():
	STATE.wave += 1

	STATE.current_colorset = STATE.wave % 3

	# <WIP> choose some difficulties here!

	# return your ship to the pool
	if STATE.you.flag:
		STATE.you.flag = 0
		STATE.ships += 1

	STATE.grid = None

	STATE.alien_base_maxhits = 30
	STATE.fire_triggering_sequence = [0]
	STATE.fire_triggering_gunhet = 100
	if STATE.wave == 2:
		STATE.alien_base_maxhits = 50
		STATE.fire_triggering_sequence = [0,8]
		STATE.fire_triggering_gunhet =  80
	if STATE.wave == 3:
		STATE.alien_base_maxhits = 70
		STATE.fire_triggering_sequence = [0,5,10]
		STATE.fire_triggering_gunhet =  60
	if STATE.wave >= 4:
		STATE.alien_base_maxhits = 100
		STATE.fire_triggering_sequence = [0,10,20,30]
		STATE.fire_triggering_gunhet =  50

	STATE.difficulty_minimum_alien_useful = 6 + STATE.wave * 3
	if STATE.difficulty_minimum_alien_useful > 20:
		STATE.difficulty_minimum_alien_useful = 20

	STATE.aliens_killed_count = 0
	STATE.aliens_killed_required = 15

	return


##################################################################
# this is used to return the game to a known "safe" state for you
# to kick off a new life
def	init_inityoustart():
	STATE.grid = DYNAMAZE( 12, 10, 128, 128, scrx, scry)
	aliens_clearall()
	bombs_clearall()
	shots_clearall()
	goods_clearall()
	expls_clearall()
	craters_clearall()
	STATE.time_since_last_player_action = 0
	STATE.wave_accelerator = 0
	STATE.bomb_speed_bonus = 0

	# when you come back on, you gotta kill SOME aliens before you get the base!
	if STATE.aliens_killed_count >= STATE.aliens_killed_required - 2:
		STATE.aliens_killed_count = STATE.aliens_killed_required - 2

	STATE.alien_base_created = 0		# for now only one per level

##################################################################
def	canvas_greet():
	c = [60,60,60]
	screen.fill( c)

	silence_all()

	if STATE.cheating == 0:
		if STATE.score > STATE.highscore:
			STATE.highscore = STATE.score
			try:
				hiscfile = open( hisc_filename, "wt")
				hiscfile.write( str( STATE.highscore))
				hiscfile.close()
			except IOError:
				pass

	VGAPRN.zerowrite = 0
	VGAPRN.color1 = (255, 255, 0)
	VGAPRN.justify = JUSTIFY_CENTER

	VGAPRN.setsize(30)
	nn = 10		# cheesy line spacing onscreen
	VGAPRN.printf( screen_size[0] / 2, 1 * screen_size[1] / nn,
					"DynaMaze - Tanks In A Dynamic Maze")
	VGAPRN.printf( screen_size[0] / 2, 2 * screen_size[1] / nn,
					"By Kurt W Dekker for PLBM Games")
	VGAPRN.printf( screen_size[0] / 2, 3 * screen_size[1] / nn,
					"http://www.plbm.com");
	VGAPRN.printf( screen_size[0] / 2, 4 * screen_size[1] / nn,
					"Press <ENTER> to begin new game");
	tmp = "Last: " + `STATE.score` + cheatarray_yesno[STATE.cheating] + " --- High: " + `STATE.highscore`
	VGAPRN.printf( screen_size[0] / 2, 5 * screen_size[1] / nn,
					tmp);
	VGAPRN.printf( screen_size[0] / 2, 6 * screen_size[1] / nn,
					"Use arrows to move and Ctrl or WASD to fire")
	VGAPRN.printf( screen_size[0] / 2, 7 * screen_size[1] / nn,
					"ESCAPE to exit and <F> to toggle Fullscreen")
	VGAPRN.printf( screen_size[0] / 2, 8 * screen_size[1] / nn,
					"(BEST to use a 4-axis joystick (dual analog))")

	joystick_think()

	if jbuttons & 15:
		STATE.canvasno = CANVAS_INITGAME

	if len( keypresses):
		if keypresses[0] == K_RETURN:
			STATE.canvasno = CANVAS_INITGAME
		if keypresses[0] == K_ESCAPE:
			global finished
			finished = True

	joystick_greet_paint()

	return

##################################################################
def	canvas_playing():
	colorsets_cls()

	you_think()
	shots_think()
	aliens_think()
	bombs_think()
	goods_think()
	expls_think()
	craters_think()

	if STATE.grid:
		STATE.grid.paint()

	update_state_bounding_rects()

	craters_paint()
	you_paint()
	goods_paint()
	shots_paint()
	aliens_paint( 0)
	bombs_paint()
	aliens_paint( 1)
	expls_paint()

#	plot( 30, 400, bomb_missile[ STATE.canvastimer % MAXROTS])

#	ss_expls_40x40_circular.plot( 70, 400, STATE.canvastimer % 10)

	stats_paint()

	if STATE.grid:
		STATE.grid.rover_changer()

	if len(unicodeses):
# cheat to gain extra lives
		if unicodeses[0] == 'X':
			STATE.cheating = 1
			STATE.ships += 1
			if STATE.ships >= 4:
				STATE.ships = 4
# cheat to jump ahead to next wave
		if unicodeses[0] == 'N':
			STATE.cheating = 1
			STATE.canvastimer = 0
			STATE.canvasno = CANVAS_ENDWAVE

	if len(keypresses):
		if keypresses[0] == K_ESCAPE:
			STATE.canvasno = CANVAS_GREET

	return

##################################################################
def	canvas_endwave():
	c = [60,60,60]
	screen.fill( c)

	silence_all()

	VGAPRN.zerowrite = 0
	VGAPRN.color1 = (255, 255, 0)
	VGAPRN.justify = JUSTIFY_CENTER

	VGAPRN.setsize(30)
	nn = 5		# cheesy line spacing onscreen
	VGAPRN.printf( screen_size[0] / 2, 1 * screen_size[1] / nn,
					"WAVE " + `STATE.wave` + " COMPLETED!")
	VGAPRN.printf( screen_size[0] / 2, 2 * screen_size[1] / nn,
					"NICE WORK!")
	VGAPRN.printf( screen_size[0] / 2, 3 * screen_size[1] / nn,
					"YOUR SCORE: " + `STATE.score`);
	if STATE.canvastimer > 30:
		VGAPRN.printf( screen_size[0] / 2, 4 * screen_size[1] / nn,
						"Press ENTER To Continue")

	joystick_think()

	if STATE.canvastimer > 30:
		if jbuttons & 15:
			STATE.canvasno = CANVAS_INITWAVE

		if len( keypresses):
			if keypresses[0] == K_RETURN:
				STATE.canvasno = CANVAS_INITWAVE
			if keypresses[0] == K_ESCAPE:
				global finished
				finished = True

	joystick_greet_paint()

	return


##################################################################

##################################################################
# This is part of Kurt Dekker's common python library codebase.
#

##################################################################
def	dispatch_canvases():
	STATE.canvastimer += 1
	if STATE.canvasno == CANVAS_GREET:
		if canvas_greet:
			canvas_greet()
		else:
			STATE.canvasno += 1
	elif STATE.canvasno == CANVAS_INITGAME:
		if init_initgame:
			init_initgame()
		STATE.canvasno += 1
	elif STATE.canvasno == CANVAS_INITWAVE:
		if init_initwave:
			init_initwave()
		STATE.canvasno += 1
	elif STATE.canvasno == CANVAS_PLAYING:
		# you absolutely MUST have a canvas_playing!
		canvas_playing()
	elif STATE.canvasno == CANVAS_ENDWAVE:
		canvas_endwave()
	else:
		STATE.canvasno = STATE.canvasno + 1
		if STATE.canvasno >= CANVAS_MAXIMUM:
			STATE.canvasno = CANVAS_GREET


##################################################################
finished = False
while not finished:

	prevkeybits = keybits[:]
	keybits = pygame.key.get_pressed()

	# you need to process ALL keypresses each frame, or else they're GONE!
	keypresses = []
	unicodeses   = []

	for e in pygame.event.get():
		if e.type == pygame.KEYDOWN:
			# these are global keypresses
			if e.unicode == 'F':
				if not fullscreen:
					screen=pygame.display.set_mode((640,480),pygame.FULLSCREEN)
					fullscreen=True
					pygame.mouse.set_visible(False)
				else:
					pygame.mouse.set_visible(True)
					screen=pygame.display.set_mode((640,480))
					fullscreen=False
			else:
				# throw the keypresses in this list so canvases can process them
				keypresses.append( e.key)
				unicodeses.append( e.unicode)

		if e.type in [pygame.QUIT]:
			finished = True
			break

	dispatch_canvases()

	pygame.display.update()

	clock.tick(30)
