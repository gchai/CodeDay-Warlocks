import sys, random, pygame
from pygame.locals import *
sys.path.append('Health/')
sys.path.append('ColorMod/')
sys.path.append('PowerUps/')
sys.path.append('Animation/Foxreflector/')
import ColorMod
import CTrail, CSegment, health, ColorMod, Pup, CAI, ClassReflector
#TODO fix bullets so that they append to a new spritegroup. this way we can have
#   multiple bullets generated by one object. code for bullet destruction and removal should be in
#   the bullet.


#~~~~~~LIGHTBIKE~~~~~~~~~~~~
# safe to mess with? : member var : purpose 
# No : style   : (str)used for update/ movement choice logic. use ChangeStyle(str) to change it
# No : but     : ([])array holding pygame button constants. [TODO make better way, enabling a player to choose what button they want.]
# yes: x       : (int)x position.
# yes: y       : (int)y position
#
#
#

class Jet():
    def __init__(self, Control = -1, x = 0, y = 0, color = (50,120,160) ):
        '''A negative control value means AI usage. A positive value is player usage. 0 is debug. Color indicates the colorize color'''
        #self.style is the style of the AI, which can be passive, evasive, or agressive (aggro).
        #style also has a decision in where testlines are located and how many it has.
        self.imgmod = 0
        self.points = 0
        self.strength = 1
        self.living = False
        self.DropLines = True
        self.__invincibility = 0
        #set living to true when spawn.
        self.img = None
        self.imglist = []
        self.imgnum = 0
        self.imglist.append(pygame.image.load('transparent.png'))
        spr = ColorMod.Filter(pygame.image.load('lights/Base.png'), color)
        self.imglist.append(spr)
        self.imglist.append(pygame.transform.rotate(spr, 180))
        self.imglist.append(pygame.transform.rotate(spr, 90))
        self.imglist.append(pygame.transform.rotate(spr, -90))
        self.imglist.append(pygame.image.load('glow.png'))
        self.imglist.append(pygame.image.load('glow_damage.png'))
        
        self.img = self.imglist[5].copy()
        self.img.blit(self.imglist[0], (0,0))
        self.imgrect = self.img.get_rect()
        self.imgrect.center = (x,y)
        
        #self.img must be a copy, not the real thing.
        #next 6 are used by Pup. safe to change clockmod, Power, hp
        self.Power = Pup.NONE
        self.__PowerFrame = 0
        self.__reset = False
        self.hp = 10
        self.__invincibility = 0
        self.TrailLength = 2000
        self.__TrailMem = 0
        
        self.bar = health.HealthBar(4,['b','g','y','r'])
        #the following is used by self.AI()
        if Control < 0:
            if Control == -1:
                self.style = "passive"
            elif Control == -2:
                self.style = "evasive"
            elif Control == -3:
                self.style = "aggro"
        elif Control > 0:
            self.but = []
            self.style = "player"
            if Control == 1:
                self.but.append(pygame.K_w)
                self.but.append(pygame.K_s)
                self.but.append(pygame.K_a)
                self.but.append(pygame.K_d)
                self.but.append(pygame.K_q)
            if Control == 2:
                self.but.append(pygame.K_i)
                self.but.append(pygame.K_k)
                self.but.append(pygame.K_j)
                self.but.append(pygame.K_l)
                self.but.append(pygame.K_u)
        else:
            self.but = []
            self.style = "player"
            self.but.append(pygame.K_UP)
            self.but.append(pygame.K_DOWN)
            self.but.append(pygame.K_LEFT)
            self.but.append(pygame.K_RIGHT)
            self.but.append(pygame.K_SPACE)
        self.AI = CAI.AI_NONE
        if (self.style =="aggro") or (self.style =="evasive") or (self.style =="passive"):
            self.AI = CAI.AI_LIGHT
        #AI uses this v. don't touch it.        
        self.AIColliders = []
        
        self.x = x
        self.y = y
        self.spSet = color
        #self.x and .y are the center of the object
        #self.spSet = a (r,g,b) object
        self.speed = 12
        #set speed between 1/3 and 1/2 of the image diameter so it looks like a nice transition.
        
        #   TODO fix collision so that it will detect everything between the front of it's last hitbox
        #      or hitLines and it's current front. This way speed can be anything and still work.
         
        self.Lines = []
        self.canAct = True
        self.acting = False
        self.actionTime = 0
        self.actionCoolDown = 15
        self.dirChanged = False
        #^ some flags and action members
        self.dir = "U"
        self.pdir = "U"
        #direction
        self.colliders = [CSegment.Segment((self.img.get_rect().left+self.img.get_width()/4, self.y), (self.img.get_rect().right-self.img.get_width()/4, self.y)), CSegment.Segment((self.x, self.img.get_rect().top+self.img.get_height()/4), (self.x, self.img.get_rect().bottom-self.img.get_height()/4))]
        #colliders. make sure to modify the appropriate ones when speed increases.
        #
        #colliders should be smaller than the image for most cases, but the rear one in any instance needs to extend by self.speed*self.spMultiplier/2.
        self.__DLINE = True
        self.__DLINENEW = False
    def Action(self):
        if self.canAct:
            self.actionTime = pygame.time.get_ticks() 
            self.DropLines = False
            
    def begin(self, screen, enemies):
        self.living = True
        self.Lines = []
        self.Lines.append(CSegment.Segment((self.x,self.y),(self.x,self.y)))
        self.hp = 10
        self.bar.SetHP(self.hp)
        self.canAct = True
        self.acting = False 
        
    def takeDamage(self, amount):
        if self.__invincibility <= 0:
            self.hp -= amount
            self.__invincibility = 15
        if self.hp <= 0:
            self.living = False
            self.img = self.imglist[0].copy()
            self.__reset = True
            self.Power(self)
            self.Power = Pup.NONE
            self.Lines = []
    
    def update(self, screen, spGroup):
        if (pygame.time.get_ticks()-self.actionTime)/1000 > self.actionCoolDown:
            self.canAct = True
        else:
            self.canAct = False
        if (pygame.time.get_ticks()-self.actionTime)/1000 > 2 and not self.DropLines:
            self.Lines.append(CSegment.Segment((self.x,self.y),(self.x,self.y)))
            self.DropLines = True
        if (pygame.time.get_ticks()-self.actionTime)/1000 < 2:
            self.__invincibility = 2
        if self.living:
            self.dirChanged = False
            hit = 0
            #get strength of whatever we hit.
            #bullets will call takeDamage directly
            for vehicle in spGroup:
                didhit = 0
                for line in vehicle.Lines:
                    if line.collideswith(self.colliders[0]):
                        hit = vehicle.strength
                        didhit = 1
                        break 
                    if line.collideswith(self.colliders[1]):
                        hit = vehicle.strength
                        didhit = 1
                        break
                if didhit:
                    break
            if hit != 0:
                self.takeDamage(hit)
            #change self.dirChanged if you change dir V.
            self.AI(self, self.style, self.__invincibility, spGroup)
            self.img = self.imglist[0].copy()
            #if ai, the following won't execute
            if not self.dirChanged and (self.style != "aggro" or self.style != "evasive" or self.style != "passive"):
                keys = pygame.key.get_pressed()
                if keys[self.but[0]]:
                    self.dir = "U"
                    self.imgnum = 1
                    self.dirChanged = True
                elif keys[self.but[1]]:
                    self.dir = "D"
                    self.imgnum = 2
                    self.dirChanged = True
                elif keys[self.but[2]]:
                    self.dir = "L"
                    self.imgnum = 3
                    self.dirChanged = True
                elif keys[self.but[3]]:
                    self.dir = "R"
                    self.imgnum = 4
                    self.dirChanged = True
                if keys[self.but[4]]:
                    self.Action()
            #move after getting dirs
            if self.living:
                self.Move()
            #TODO find way to execute actions
            curlen = 1
            i = len(self.Lines)-1
            #deletes lines
            
            while i >= 0:
                curlen += self.Lines[i].length()
                if curlen > self.TrailLength:
                    if curlen - self.TrailLength > self.Lines[i].length():
                        self.Lines.pop(i)
                    else:
                        #TODO adjust Line length here
                        if self.Lines[i].st[0] == self.Lines[i].end[0]:
                            #vertical line
                            if self.Lines[i].st[1] > self.Lines[i].end[1]:
                                #points up.
                                self.Lines[i].st[1]-=(curlen-self.TrailLength)
                            else:
                                #points down.
                                self.Lines[i].st[1]+=(curlen-self.TrailLength)
                        elif self.Lines[i].st[1] == self.Lines[i].end[1]:
                            #horizontal line
                            if self.Lines[i].st[0] > self.Lines[i].end[0]:
                                #points left
                                self.Lines[i].st[0]-=(curlen-self.TrailLength)
                            else:
                                #points right
                                self.Lines[i].st[0]+=(curlen-self.TrailLength)
                i-=1
                
            if self.__invincibility > 0:
                self.__invincibility -=1
      
    def Move(self):
        if self.dir == "U":
            self.y -= self.speed
        elif self.dir == "D":
            self.y += self.speed
        elif self.dir == "L":
            self.x -= self.speed
        elif self.dir == "R":
            self.x += self.speed
        self.colliders[0].st = [self.x-self.speed/2,self.y]        
        self.colliders[0].end = [self.x+self.speed/2,self.y]
        self.colliders[1].st = [self.x,self.y+self.speed/2]
        self.colliders[1].end = [self.x,self.y-self.speed/2]
        #same direction.
        if self.dir == "U":
            if self.DropLines:
                self.Lines[-1].end = [self.x, self.y + self.speed]
        if self.dir == "D":
            if self.DropLines:
                self.Lines[-1].end = [self.x, self.y - (self.speed)]
        if self.dir == "L":
            if self.DropLines:
                self.Lines[-1].end = [self.x + (self.speed), self.y]
        if self.dir == "R":
            if self.DropLines:
                self.Lines[-1].end = [self.x - (self.speed), self.y]
        if self.dir != self.pdir:
            self.Lines.append(CSegment.Segment((self.Lines[-1].end),(self.Lines[-1].end)))
        self.pdir = self.dir
            
                
    def Draw(self, screen):
        if self.__invincibility > 0:
            self.imgmod = 1
        else:
            self.imgmod = 0
        self.img = self.imglist[5+self.imgmod].copy()
        if self.living:
            if self.dir == "U":
                self.img.blit(self.imglist[1],(0,0))
            elif self.dir == "D":
                self.img.blit(self.imglist[2],(0,0))
            elif self.dir == "L":
                self.img.blit(self.imglist[3],(0,0))
            elif self.dir == "R":
                self.img.blit(self.imglist[4],(0,0))        
            
            
        self.bar.SetHP(self.hp)
        self.bar.Draw(self.img, (0, self.img.get_height()-6))
        screen.blit(self.img, (self.x-self.img.get_width()/2, self.y-self.img.get_height()/2))
        if len(self.Lines) >= 1:
            for line in self.Lines:
                pygame.draw.lines(screen, self.spSet, False, (line.st, line.end), int(random.randint(1,4)))
            
